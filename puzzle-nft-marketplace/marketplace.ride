{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let createNftDapp = base58'3PFQjjDMiZKQZdu5JqTHD7HwgSXyp9Rw9By'
let marketFeeAddress = Address(base58'3PEa88W5it7LVPVwtpZDfYajQQWkxFNG8qf')
let puzzleStateAddress = base58'3PFTbywqxtFfukX3HyT881g4iW5K4QL3FAS'

# wrapper contracts
let nftDuckWrapper = base58'3P3pDosq4GCwfJkvq4yqKvvoTwmoqc9qPmo'
let nftSignArtWrapper = base58'3PPgeYTWMRZ7S7jSLpnVuKKB9r6XuDk3ndC'

let royaltyPercent = 7

func checkNFT(asset: Asset) = {
  asset.issuer.bytes == createNftDapp && asset.decimals == 0 && asset.reissuable == false && asset.quantity == 1
}

func tryGetInteger(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
      case _ => 0
  }
}

func tryGetString(key: String) = {
  match getString(this, key) {
      case b:String => b
      case _ => ""
  }
}

func tryGetAssetInfo(assetId: String, errorMsg: String) = {
  match assetInfo(assetId.fromBase58String()) {
    case a:Asset => a
    case _ => throw(errorMsg)
  }
}

func getAssetString(assetId: ByteVector|Unit) = {
  match assetId {
    case b:ByteVector => b.toBase58String()
    case _ => "WAVES"
  }
}

func getAssetBytes(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {unit} else {assetIdStr.fromBase58String()}
}

@Callable(i)
func sellNFT(buyOutPrice: Int, buyOutAssetId: String) = {

  let pmt = if i.payments.size() == 1 && i.payments[0].amount == 1
    then i.payments[0]
    else throw("NFT not listed as payment")

  let buyOutAsset = buyOutAssetId.getAssetBytes()

  if (isDefined(pmt.assetId)) then {
    let nftId = value(pmt.assetId)
    let nft = match assetInfo(nftId) {
      case a:Asset => a
      case _ => throw("Can't find NFT")
    }

    if (checkNFT(nft)) then {
      if (buyOutPrice > 0) then {

        let assetNameStr = toBase58String(nft.id)
        let nftIssuer = match getString(Address(createNftDapp), "nft_" + assetNameStr + "_issuer") {
          case a: String => a
          case _ => i.caller.toString()
        }
        let royaltyReceiver = if (nftIssuer != nftSignArtWrapper.toBase58String()) then {
          nftIssuer
        } else {
          assetInfo(nftId).value().description.split(" ")[2].split(".")[0]
        }
        
        [
          IntegerEntry("nft_" + assetNameStr + "_buyOutPrice", buyOutPrice),
          StringEntry("nft_" + assetNameStr + "_buyOutAssetId", buyOutAsset.getAssetString()),
          StringEntry("nft_" + assetNameStr + "_royaltyReceiver", royaltyReceiver),
          StringEntry("nft_" + assetNameStr + "_seller", i.originCaller.toString()),
          StringEntry("address_" + i.originCaller.toString() + "_nft_" + assetNameStr, assetNameStr),
          IntegerEntry("address_" + i.originCaller.toString() + "_nft_" + assetNameStr + "_startSaleAt", height)
        ]

      } else throw("Price must be greater than zero")
    } else throw("NFT issued by another dapp")
  } else throw("NFT is not attached to the transaction")
}

@Callable(i)
func buyNFT(nftId: String) = {
  let pmt = if i.payments.size() == 1
    then i.payments[0]
    else throw("Attached payment is required")

  let buyOutPrice = tryGetInteger("nft_" + nftId + "_buyOutPrice")
  let buyOutAssetId = tryGetString("nft_" + nftId + "_buyOutAssetId")
  let royaltyReceiver = tryGetString("nft_" + nftId + "_royaltyReceiver")
  let sellerStr = tryGetString("nft_" + nftId + "_seller")

  let nftAsset = tryGetAssetInfo(nftId, "NFT not found")
  let buyOutAsset = tryGetAssetInfo(buyOutAssetId, "Buyout asset not found")

  if (buyOutPrice > 0 && pmt.amount >= buyOutPrice) then {

    # calculate royalty
    let royaltyPart = fraction(buyOutPrice, royaltyPercent, 100)
    let marketFee = fraction(buyOutPrice, 3, 100)

    if (pmt.assetId == buyOutAsset.id) then {
      ([
        ScriptTransfer(i.caller, 1, nftAsset.id),
        ScriptTransfer(Address(sellerStr.fromBase58String()), buyOutPrice - royaltyPart - marketFee, buyOutAsset.id),
        ScriptTransfer(Address(royaltyReceiver.fromBase58String()), royaltyPart, buyOutAsset.id),
        ScriptTransfer(marketFeeAddress, marketFee, buyOutAsset.id),

        DeleteEntry("nft_" + nftId + "_buyOutPrice"),
        DeleteEntry("nft_" + nftId + "_buyOutAssetId"),
        DeleteEntry("nft_" + nftId + "_royaltyReceiver"),
        DeleteEntry("nft_" + nftId + "_seller"),
        DeleteEntry("address_" + sellerStr + "_nft_" + nftId),
        DeleteEntry("address_" + sellerStr + "_nft_" + nftId + "_startSaleAt")
      ], nftAsset.id.toBase58String())
    } else throw("The buyout asset does not match the purchase asset")
  } else throw("Payment amount must be greater than zero")
}

@Callable(i)
func cancelSell(nftId: String) = {
  let sellerStr = tryGetString("nft_" + nftId + "_seller")

  let nftAsset = tryGetAssetInfo(nftId, "NFT not found")

  if (size(sellerStr) > 0 && sellerStr == i.originCaller.toString()) then {
    ([
      ScriptTransfer(i.caller, 1, nftAsset.id),

      DeleteEntry("nft_" + nftId + "_buyOutPrice"),
      DeleteEntry("nft_" + nftId + "_buyOutAssetId"),
      DeleteEntry("nft_" + nftId + "_royaltyReceiver"),
      DeleteEntry("nft_" + nftId + "_seller"),
      DeleteEntry("address_" + sellerStr + "_nft_" + nftId),
      DeleteEntry("address_" + sellerStr + "_nft_" + nftId + "_startSaleAt")
    ], nftId)
  } else throw("You are not a seller")
}

@Callable(i)
func like(nftId: String) = {
  let nftAsset = assetInfo(nftId.fromBase58String())

  let isDuckNft = getString(Address(nftDuckWrapper), "nft_" + nftId + "_duckId").isDefined()
  let isSignArtNft = getString(Address(nftSignArtWrapper), "signArtNft_" + nftId + "_assetId").isDefined()

  if (nftAsset.isDefined() && !isDuckNft && !isSignArtNft && checkNFT(nftAsset.value())) then {

    let callerAddress = i.caller.toString()
    let countStaked = match getInteger(Address(puzzleStateAddress), callerAddress + "_staked") {
      case c:Int => c
      case _ => 0
    }

    if (countStaked >= 1_0000_0000) then {
      let nftLikesKey = "nft_" + nftId + "_likes"
      let nftLikesValue = tryGetString("nft_" + nftId + "_likes")

      if (!nftLikesValue.indexOf(callerAddress).isDefined()) then {
        let newLikesValue = if (nftLikesValue.size() == 0 ) then {
          i.caller.toString()
        } else {
          nftLikesValue + "," + callerAddress
        }

        [
          StringEntry(nftLikesKey, newLikesValue)
        ]
      } else throw("You have already voted")
    } else throw("You can like if you stake 1 or more Puzzles")
  } else throw("Invalid NFT id")
  
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)

{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let marketplaceContractAddress = Address(base58'3PATXDVE53rKJtkwXYV3tvuLVS2fDtGtKCc')

let issuersWhitelist = [
  "3P3iV85eXfkcA3Dd13EpZBYvs1vkKX6AYEN",
  "3PHFAavxj2ePJqFB46H2aRGA7oQL6kz1rJJ",
  "3P6peovAkVN3px6Zuv8y2noTWHFM4R5Wjj8",
  "3P5CQkvk8Pu6rGP3Qav4Lwskwa8pLhNwTbR",
  "3PHKDCQScvSPHvdCUeucFkx5Q1xMURA9kbr",
  "3PMki5sHBsQb4KgDknbUwsL3YgxaCzaZnCJ",
  "3P2wMCDjtxeLdfQrpR8WUe5zNeScM4UaL3o",
  "3P3pDosq4GCwfJkvq4yqKvvoTwmoqc9qPmo",
  "3PPgeYTWMRZ7S7jSLpnVuKKB9r6XuDk3ndC",
  "3PKVgd6ds1xervK6bPXbEHBqg8ibTcf5HZk", # ultra staking wrapper
  "3PD1sd55PYzmGUrQ896Qt3uvdbtgjCVpajE", # waves punks wrapper
  "3PFkgvC9y6zHy64zEAscKKgaNY3yipiLqbW",
  "3PGGSiLuwGmm7ChfjDrmEZBd6HxQJn8N1NM",
  "3PJKmXoHJvVeQXjSJdhtkUcFDtdiQqMbUTD", # puzzle gang Vitaly
  "3P5bL6V4oGTZtMTirj9WxtbxUntqXdjevAE", # puzzle gang Vadim
  "3PCyjqHhtq9f9Hmn4LNsWwA68dFVsvQ6iNi", # puzzle gang Alexandra
  "3PKHFX6W4aAr1e1b8MUTz5HmdWVUcjWhgY4", # puzzle gang Alex Stanovoy
  "3PJVkx7XRo86zU88shLuKGmbRr7RkMSxjHj", # address from Ania
  "3PLu7coMNV4naCxWkRemqga6o9zUhQppxsA"  # winner
]

func tryGetInteger(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
      case _ => 0
  }
}

func tryGetString(key: String) = {
  match getString(this, key) {
      case b:String => b
      case _ => ""
  }
}

func checkNFT(asset: Asset) = {
  asset.issuer.bytes == this.bytes && asset.decimals == 0 && asset.reissuable == false && asset.quantity == 1
}

func checkName(name: String) = {
  if (name.size() > 0 && name.size() < 17) then name else throw("Wrong NFT name")
}

func getParamByKey(key: String, params: List[String]) = {
  func find(accum: String, next: String) = {
    if (accum.size() == 0) then {
      let parsed = next.split("::")
      if (parsed[0] == key) then parsed[1] else accum
    } else accum
  }

  FOLD<10>(params, "", find)
}


@Callable(i)
func createNFT(nftName: String, nftDesc: String, image: String, collectionName: String) = {
  if (issuersWhitelist.indexOf(i.caller.toString()) == unit) then {throw("issuance of new NFTs is limited")}
  else if (image.indexOf("https://") != 0) then {
    throw("https link to image required")
  } else {
    let asset = Issue(nftName, nftDesc, 1, 0, false, unit, 0)
    let assetId = asset.calculateAssetId()
    let assetIdStr = assetId.toBase58String()

    let collectionDomain = i.caller.toString() + "_" + if (collectionName.size() > 0) then {collectionName} else {"basic"}
    let nftNum = tryGetInteger("collection_" + collectionDomain + "_size") + 1
    
    ([
      StringEntry("nft_" + assetIdStr + "_data", "{'collection': '"+collectionDomain+"', 'num': "+nftNum.toString()+"}"),
      StringEntry("nft_" + assetIdStr + "_image", image),
      StringEntry("nft_" + assetIdStr + "_issuer", i.caller.toString()),

      IntegerEntry("collection_" + collectionDomain + "_size", nftNum),
      StringEntry("collection_" + collectionDomain + "_assetId_" + assetIdStr, assetIdStr),

      asset,
      ScriptTransfer(i.caller, 1, assetId)
    ], assetIdStr)
  }
}

@Callable(i)
func mint(params: String, isGroup: Boolean) = {
  # params format: name::xxx||desc::xxx||collection::xxx||original::xxx||preview::xxx||amount::xxx(only for group)
  let parsedParams = params.split("||")
  # let f = if (parsedParams.size() < 4) then throw("Wrong call params") else unit

  let nftName = checkName(getParamByKey("name", parsedParams))
  let nftDesc = getParamByKey("desc", parsedParams)
  let collectionName = getParamByKey("collection", parsedParams)

  let origFile = getParamByKey("original", parsedParams)
  let preview = getParamByKey("preview", parsedParams)
  let previewFile = if (preview.size() > 0) then preview else origFile

  if (issuersWhitelist.indexOf(i.caller.toString()) == unit) then
    throw("issuance of new NFTs is limited")
  else if (collectionName.size() == 0) then
    throw("Incorrect collection name")
  else if (origFile.indexOf("https://") != 0 || previewFile.indexOf("https://") != 0) then {
    throw("https link to file required")
  } else {
    let asset = Issue(nftName, nftDesc, 1, 0, false, unit, 0)
    let assetId = asset.calculateAssetId()
    let assetIdStr = assetId.toBase58String()

    # issue 1 nft
    if (!isGroup) then {
      let collectionDomain = i.caller.toString() + "_" + if (collectionName.size() > 0) then {collectionName} else {"basic"}
      let nftNum = tryGetInteger("collection_" + collectionDomain + "_size") + 1

      ([
        StringEntry("nft_" + assetIdStr + "_data", "{'collection': '"+collectionDomain+"', 'num': "+nftNum.toString()+"}"),
        StringEntry("nft_" + assetIdStr + "_image", previewFile),
        StringEntry("nft_" + assetIdStr + "_original", origFile),
        StringEntry("nft_" + assetIdStr + "_issuer", i.caller.toString()),

        IntegerEntry("collection_" + collectionDomain + "_size", nftNum),
        StringEntry("collection_" + collectionDomain + "_assetId_" + assetIdStr, assetIdStr),

        asset,
        ScriptTransfer(i.caller, 1, assetId)
      ], assetIdStr)
    } else { # issue 1 group nft
      let collectionAmount = match parseInt(getParamByKey("amount", parsedParams)) {
        case x:Int => x
        case _ => 0
      }
      if (collectionAmount > 1) then {
        let collectionDomain = i.caller.toString() + "_" + collectionName

        ([
          StringEntry("nft_" + assetIdStr + "_data", "{'collection': '"+collectionDomain+"'}"),
          StringEntry("nft_" + assetIdStr + "_image", previewFile),
          StringEntry("nft_" + assetIdStr + "_original", origFile),
          StringEntry("nft_" + assetIdStr + "_issuer", i.caller.toString()),
          BooleanEntry("nft_" + assetIdStr + "_isGroup", true),

          IntegerEntry("group_" + assetIdStr + "_size", collectionAmount),
          IntegerEntry("group_" + assetIdStr + "_available", collectionAmount),
          StringEntry("group_" + assetIdStr + "_collectionDomain", collectionDomain),

          asset,
          ScriptTransfer(i.caller, 1, assetId)
        ], assetIdStr)
      } else throw("When creating a multiple collection, the number must be greater than 1")
      
    }
  }
}

@Callable(i)
func mintFromGroup(groupAssetIdStr: String) = {
  let groupAsset = assetInfo(groupAssetIdStr.fromBase16String()).value()

  if (groupAsset.checkNFT()) then {
    if (i.caller == marketplaceContractAddress) then {
      let isGroup = getBoolean("nft_" + groupAssetIdStr + "_isGroup").valueOrElse(false)
      if (isGroup) then {
        let groupSize = getInteger("group_" + groupAssetIdStr + "_size").valueOrElse(0)
        let groupAvailable = getInteger("group_" + groupAssetIdStr + "_available").valueOrElse(0)
        if (groupAvailable > 0 && groupSize > 0) then {
          #params
          let collectionDomain = getString("group_" + groupAssetIdStr + "_collectionDomain").value()
          
          let origFile = getString("nft_" + groupAssetIdStr + "_original").value()
          let previewFile = getString("nft_" + groupAssetIdStr + "_image").value()

          let nftNum = tryGetInteger("collection_" + collectionDomain + "_size") + 1

          # update group state
          let groupUpdateState = if (groupAvailable > 1) then {
            [
              IntegerEntry("group_" + groupAssetIdStr + "_available", groupAvailable - 1)
            ]
          } else {
            [
              DeleteEntry("nft_" + groupAssetIdStr + "_data"),
              DeleteEntry("nft_" + groupAssetIdStr + "_image"),
              DeleteEntry("nft_" + groupAssetIdStr + "_original"),
              DeleteEntry("nft_" + groupAssetIdStr + "_issuer"),
              DeleteEntry("nft_" + groupAssetIdStr + "_isGroup"),

              DeleteEntry("group_" + groupAssetIdStr + "_size"),
              DeleteEntry("group_" + groupAssetIdStr + "_available"),
              DeleteEntry("group_" + groupAssetIdStr + "_collectionDomain"),
              Burn(groupAssetIdStr.fromBase58String(), 1)
            ]
          }

          # issue NFT
          let asset = Issue(groupAsset.name, groupAsset.description, 1, 0, false, unit, 0)
          let assetId = asset.calculateAssetId()
          let assetIdStr = assetId.toBase58String()

          ([
            StringEntry("nft_" + assetIdStr + "_data", "{'collection': '"+collectionDomain+"', 'num': "+nftNum.toString()+"}"),
            StringEntry("nft_" + assetIdStr + "_image", previewFile),
            StringEntry("nft_" + assetIdStr + "_original", origFile),
            StringEntry("nft_" + assetIdStr + "_issuer", i.caller.toString()),

            IntegerEntry("collection_" + collectionDomain + "_size", nftNum),
            StringEntry("collection_" + collectionDomain + "_assetId_" + assetIdStr, assetIdStr),

            asset,
            ScriptTransfer(i.caller, 1, assetId)
          ] ++ groupUpdateState, assetIdStr)
        } else throw("Mint not available")
      } else throw("Invalid NFT identifier")
    } else throw("Invalid caller address")
  } else throw("Wrong NFT Id")
}

@Callable(i)
func burnNFT() = {
  let assetId = i.payments[0].value().assetId.value()
  let asset = assetInfo(assetId).value()

  if (i.payments[0].value().amount == 1 && asset.checkNFT()) then {
    let assetIdStr = assetId.toBase58String()
    let issuer = tryGetString("nft_" + assetIdStr + "_issuer")
    let data = tryGetString("nft_" + assetIdStr + "_data")

    let partsData = data.split(", ")
    let partsCollection = partsData[0].split(": ")
    let collectionDomain = partsCollection[1].drop(1).dropRight(1)

    let isGroup = getBoolean("nft_" + assetIdStr + "_isGroup").valueOrElse(false)
    if (!isGroup) then {
      let nftNum = tryGetInteger("collection_" + collectionDomain + "_size")
      if (nftNum > 0) then {
        let updateCollection = if (nftNum == 1)
          then DeleteEntry("collection_" + collectionDomain + "_size")
          else IntegerEntry("collection_" + collectionDomain + "_size", nftNum - 1)
        [
          updateCollection,
          Burn(assetId, 1),

          DeleteEntry("nft_" + assetIdStr + "_data"),
          DeleteEntry("nft_" + assetIdStr + "_image"),
          DeleteEntry("nft_" + assetIdStr + "_original"),
          DeleteEntry("nft_" + assetIdStr + "_issuer"),
          DeleteEntry("nft_" + assetIdStr + "_isGroup"),

          DeleteEntry("group_" + assetIdStr + "_size"),
          DeleteEntry("group_" + assetIdStr + "_available"),
          DeleteEntry("group_" + assetIdStr + "_collectionDomain"),

          DeleteEntry("collection_" + collectionDomain + "_assetId_" + assetIdStr)
        ]
      } else throw("Ivalid collection name")
    } else {
      [
        Burn(assetId, 1),

        DeleteEntry("nft_" + assetIdStr + "_data"),
        DeleteEntry("nft_" + assetIdStr + "_image"),
        DeleteEntry("nft_" + assetIdStr + "_original"),
        DeleteEntry("nft_" + assetIdStr + "_issuer"),
        DeleteEntry("nft_" + assetIdStr + "_isGroup"),

        DeleteEntry("group_" + assetIdStr + "_size"),
        DeleteEntry("group_" + assetIdStr + "_available"),
        DeleteEntry("group_" + assetIdStr + "_collectionDomain")
      ]
    }
  } else throw("Ivalid NFT attached")
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)

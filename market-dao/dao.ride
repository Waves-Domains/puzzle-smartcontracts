{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let creationAddress = Address(base58'3PFQjjDMiZKQZdu5JqTHD7HwgSXyp9Rw9By')

let USDTAssetId = base58'34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ'

let totalStakedKey = "total_staked"
let totalPowerKey = "total_power"

let allStakedAddressesKey = "all_staked_addresses"

let POWER_LIMIT = 1000

let whitelist = [
  "3PJKmXoHJvVeQXjSJdhtkUcFDtdiQqMbUTD"
]

# Check NFT and NFT issuer
func checkNFT(asset: Asset) = {
  getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_issuer") == this.toString() &&
  asset.issuer == creationAddress &&
  asset.decimals == 0 &&
  asset.reissuable == false &&
  asset.quantity == 1
}

func getPowerNFT(asset: Asset) = {
  let params = getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_params")
  if params == "gold" then 100 else 40
}

func getCollectionIssuer(collectionId: String) = {
  let assetId = getString(creationAddress, "collection_" + collectionId + "_assetId").valueOrElse("")

  getString(creationAddress, "nft_" + assetId + "_issuer").valueOrElse("")
}

func isVotingClosed(voteId: String) = {
  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let isConfirmed = getBoolean(voteConfirmedKey).valueOrElse(false)
  let isRejected = getBoolean(voteRejectedKey).valueOrElse(false)
  isConfirmed || isRejected
}

# add address to state staked addresses
func addAddressToStakedAll(address: String) = {
  let allStakedAddresses = getString(allStakedAddressesKey).valueOrElse("")
  if (!isDefined(allStakedAddresses.indexOf(address))) then {
    if (allStakedAddresses.size() == 0) then {
      [StringEntry(allStakedAddressesKey, address)]
    } else {
      [StringEntry(allStakedAddressesKey, (allStakedAddresses.split_51C(",") :+ address).makeString_11C(","))]
    }
  } else {
    []
  }
}

# remove address from state staked addresses
func removeAddressFromStakedAll(address: String) = {
  let allStakedAddresses = getString(allStakedAddressesKey).valueOrErrorMessage("All staked address string not found")
  if (isDefined(allStakedAddresses.indexOf(address))) then {
    let addressesList = allStakedAddresses.split_51C(",")
    let addressIndex = addressesList.indexOf(address).value()
    [StringEntry(allStakedAddressesKey, addressesList.removeByIndex(addressIndex).makeString_11C(","))]
  } else {
    []
  }
}

# func addRewardsToAddresses(assetId: String, amount: Int) = {
#   let totalPower = getInteger(totalPowerKey).valueOrErrorMessage("Total power not found")
#   if (totalPower == 0) then throw("Total power must not be zero")
#   else {
#     let asset = assetInfo(assetId.fromBase58String()).valueOrErrorMessage("Invalid asset")
#     let amountPerPower = fraction(amount, asset.decimals, totalPower)
#     if (amountPerPower > 0) then {
#       let stakedAddresses = getString(allStakedAddressesKey).valueOrErrorMessage("Staked addresses not found")
#       if (stakedAddresses.size() == 0) then throw("Staked addresses empty")
#       else {
#         let addressesList = stakedAddresses.split_51C(",")
#         let rewardsListKey = "rewards_" + assetId
#         let rewardsListStr = getString(rewardsListKey).valueOrElse("")
        
#         let resultList = if (rewardsListStr.size() == 0) then {
#           func addAddressRewards(accum: List[String], next: String) = {
#             let addressPower = getInteger("address_" + next + "_power").valueOrElse(0)
#             if (addressPower > 0) then {
#               accum :+ (next + "_" + fraction(addressPower, amountPerPower, 1).toString())
#             } else accum
#           }
#           FOLD<150>(addressesList, [], addAddressRewards)
#         } else {
#           let rewardsList = rewardsListStr.split_51C(",")
#           func updateAdressRewards(accum: List[String], next: String) = {
#             let parts = next.split("_")
#             let address = parts[0]
#             let addressAmnt = parseInt(parts[1]).valueOrElse(0)
#             if (isDefined(addressesList.indexOf(address))) then {
#               let addressPower = getInteger("address_" + address + "_power").valueOrElse(0)
#               if (addressPower > 0) then {
#                 accum :+ (address + "_" + (addressAmnt + fraction(addressPower, amountPerPower, 1)).toString())
#               } else accum :+ next
#             } else accum :+ next
#           }
#           FOLD<150>(rewardsList, [], updateAdressRewards)
#         }

#         if (resultList.size() > 0) then {
#           [StringEntry(rewardsListKey, resultList.makeString_11C(","))]
#         } else []
#       }
#     } else throw("Invalid amount per power")
#   }
# }

@Callable(i)
func stake() = {
  let addressStr = i.caller.toString()
  let p = i.payments[0].valueOrErrorMessage("No payments")
  let asset = assetInfo(p.assetId.valueOrErrorMessage("Invalid payment")).valueOrErrorMessage("Invalid asset Id")
  if (p.amount > 0 && asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPowerKey = "address_" + addressStr + "_power"
    let addressTotalStakedKey = "address_" + addressStr + "_totalStaked"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let addressPower = getInteger(addressPowerKey).valueOrElse(0)
    let addressTotalStaked = getInteger(addressTotalStakedKey).valueOrElse(0)
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrElse("")

    if (addressTotalStaked + 1 >= 5) then throw("You can stake only 5 NFTs")
    else {
      let nftPower = asset.getPowerNFT()

      let nftIdStr = asset.id.toBase58String()

      let addressStakedNftsState = if (addressStakedNfts.size() == 0) then {
        [StringEntry(addressStakedNftsKey, nftIdStr)]
      } else {
        [StringEntry(addressStakedNftsKey, (addressStakedNfts.split(",") :+ nftIdStr).makeString(","))]
      }

      [
        IntegerEntry(totalStakedKey, totalStaked + 1),
        IntegerEntry(totalPowerKey, totalPower + nftPower),

        StringEntry("nft_" + nftIdStr + "_owner", addressStr),
        IntegerEntry("nft_" + nftIdStr + "_power", nftPower),

        IntegerEntry(addressPowerKey, addressPower + nftPower),
        IntegerEntry(addressTotalStakedKey, addressTotalStaked + 1)
      ] ++ addAddressToStakedAll(addressStr) ++ addressStakedNftsState
    }
  }
  else throw("No payments")
}

@Callable(i)
func unstake(nftIdStr: String) = {
  let addressStr = i.caller.toString()
  let asset = assetInfo(nftIdStr.fromBase58String()).valueOrErrorMessage("Invalid nft Id")
  let ownerAddress = getString("nft_" + nftIdStr + "_owner").valueOrErrorMessage("Owner data invalid")
  if (ownerAddress != addressStr) then throw("You are not the owner")
  else if (asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPowerKey = "address_" + addressStr + "_power"
    let addressTotalStakedKey = "address_" + addressStr + "_totalStaked"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let addressPower = getInteger(addressPowerKey).valueOrErrorMessage("Address power value not found")
    let addressTotalStaked = getInteger(addressTotalStakedKey).valueOrErrorMessage("Address total staked value not found")
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrErrorMessage("Address staked Nfts value not found")

    let nftAssetIdStr = asset.id.toBase58String()
    let nftPower = getIntegerValue("nft_" + nftAssetIdStr + "_power")
    
    let updatedAddressPower = addressPower - nftPower
    let removeStakedAddress = if (updatedAddressPower == 0) then removeAddressFromStakedAll(addressStr) else []

    let addressStakedNftsList = addressStakedNfts.split(",")
    let addressStakedNftIndex = addressStakedNftsList.indexOf(nftIdStr).valueOrErrorMessage("NFT not founed in address staked list")
    [
      ScriptTransfer(i.caller, 1, asset.id),
      IntegerEntry(totalStakedKey, totalStaked - 1),
      IntegerEntry(totalPowerKey, totalPower - nftPower),

      DeleteEntry("nft_" + nftAssetIdStr + "_owner"),
      DeleteEntry("nft_" + nftAssetIdStr + "_power"),

      IntegerEntry(addressPowerKey, updatedAddressPower),
      IntegerEntry(addressTotalStakedKey, addressTotalStaked - 1),

      StringEntry(addressStakedNftsKey, (addressStakedNftsList.removeByIndex(addressStakedNftIndex)).makeString(","))
    ] ++ removeStakedAddress
  }
  else throw("Invalid nft Id")
}

@Callable(i)
func sendToVote(collectionId: String) = {
  let issuer = collectionId.getCollectionIssuer()
  let isExist = match (getString("collection_" + collectionId + "_voteId")) {
      case t:String => true
      case _ => false
    }
  if (issuer.size() == 0) then throw("Collection issuer not found")
  else if (isExist) then throw("Collection has already been submitted for voting")
  else if (whitelist.indexOf(i.caller.toString()) == unit) then throw("Functionality temporarily unavailable")
  else if (issuer != i.caller.toString()) then throw("Only the issuer can submit to the vote")
  else {
    let voteId = sha256_16Kb(collectionId.toBytes()).toBase58String()
    let totalVotes = getInteger("total_votes").valueOrElse(0)
    [
      StringEntry("collection_" + collectionId + "_voteId", voteId),
      StringEntry("vote_" + voteId + "_collectionId", collectionId),
      StringEntry("vote_" + voteId + "_owner", i.caller.toString()),
      IntegerEntry("vote_" + voteId + "_createdAt", height),
      IntegerEntry("total_votes", totalVotes + 1)
    ]
  }
}

@Callable(i)
func removeFromVote(voteId: String) = {
  let collectionId = getString("vote_" + voteId + "_collectionId").valueOrErrorMessage("Collection Id not found")
  let owner = getString("vote_" + voteId + "_owner").valueOrErrorMessage("Owner not found")
  if (owner != i.caller.toString()) then throw("You are not the owner")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else {
    let totalVotes = getInteger("total_votes").valueOrErrorMessage("total votes value not found")
    [
      DeleteEntry("collection_" + collectionId + "_voteId"),
      DeleteEntry("vote_" + voteId + "_collectionId"),
      DeleteEntry("vote_" + voteId + "_owner"),
      DeleteEntry("vote_" + voteId + "_createdAt"),
      IntegerEntry("total_votes", totalVotes - 1)
    ]
  }
}

@Callable(i)
func vote(voteId: String, type: String) = {
  let addressStr = i.caller.toString()

  let exist = match (getString("vote_" + voteId + "_collectionId")) {
    case t:String => true
    case _ => false
  }

  let voterVoteKey = "voter_" + addressStr + "_vote_" + voteId + "_isVoted"
  let voterVoteTypeKey = "voter_" + addressStr + "_vote_" + voteId + "_type"
  let voterVotePowerKey = "voter_" + addressStr + "_vote_" + voteId + "_power"
  let voterVoteCreatedKey = "voter_" + addressStr + "_vote_" + voteId + "_created"

  let voterVotesCountKey = "voter_" + addressStr + "_votesCount"
  let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

  let voteUpCountKey = "vote_" + voteId + "_upCount"
  let voteDownCountKey = "vote_" + voteId + "_downCount"
  let voteTotalCountKey = "vote_" + voteId + "_totalCount"

  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let addressPower = getInteger("address_" + addressStr + "_power").valueOrErrorMessage("The address has no voting power")
  let totalVoteCount = getInteger(voteTotalCountKey).valueOrElse(0)

  let voterVotesCount = getInteger(voterVotesCountKey).valueOrElse(0)
  let voterSpentPower = getInteger(voterSpentPowerKey).valueOrElse(0)

  let upCountDapp = getInteger(voteUpCountKey).valueOrElse(0)
  let downCountDapp = getInteger(voteDownCountKey).valueOrElse(0)

  let upCount = if (type == "up") then upCountDapp + addressPower else upCountDapp
  let downCount = if (type == "down") then downCountDapp + addressPower else downCountDapp

  let isCallerVoted = getBoolean(voterVoteKey).valueOrElse(false)

  if (isCallerVoted) then throw("You have already voted")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else if (!exist) then throw("Collection not found")
  else if(type != "up" && type != "down") then throw("Invalid type parametr")
  else {
    let updatedVoteCount = totalVoteCount + addressPower
    let endVoteStates = if (updatedVoteCount >= POWER_LIMIT) then {
      let upPercent = fraction(upCount, 100, updatedVoteCount)
      let downPercent = fraction(downCount, 100, updatedVoteCount)
      if (upPercent >= 50) then [
        BooleanEntry(voteConfirmedKey, true)
      ]
      else [
        BooleanEntry(voteRejectedKey, true)
      ]
    } else []
    [
      BooleanEntry(voterVoteKey, true),
      StringEntry(voterVoteTypeKey, type),
      IntegerEntry(voterVoteCreatedKey, height),
      IntegerEntry(voterVotePowerKey, addressPower),
      IntegerEntry(voterVotesCountKey, voterVotesCount + 1),
      IntegerEntry(voterSpentPowerKey, voterSpentPower + addressPower),

      IntegerEntry(voteUpCountKey, upCount),
      IntegerEntry(voteDownCountKey, downCount),

      IntegerEntry(voteTotalCountKey, updatedVoteCount)
    ] ++ endVoteStates
  }
}

@Callable(i)
func unvote(voteId: String) = {
  let addressStr = i.caller.toString()

  let voterVoteKey = "voter_" + addressStr + "_vote_" + voteId + "_isVoted"
  let voterVoteTypeKey = "voter_" + addressStr + "_vote_" + voteId + "_type"
  let voterVotePowerKey = "voter_" + addressStr + "_vote_" + voteId + "_power"
  let voterVoteCreatedKey = "voter_" + addressStr + "_vote_" + voteId + "_created"

  let voterVotesCountKey = "voter_" + addressStr + "_votesCount"
  let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

  let voteUpCountKey = "vote_" + voteId + "_upCount"
  let voteDownCountKey = "vote_" + voteId + "_downCount"
  let voteTotalCountKey = "vote_" + voteId + "_totalCount"

  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let voteIdType = getString(voterVoteTypeKey).valueOrErrorMessage("Vote Id type not founded")
  let voteIdPower = getInteger(voterVotePowerKey).valueOrErrorMessage("Vote Id power not founded")
  let totalCount = getInteger(voteTotalCountKey).valueOrErrorMessage("Vote Id total count not founded")

  let voterVotesCount = getInteger(voterVotesCountKey).valueOrErrorMessage("Voter votes count value not founded")
  let voterSpentPower = getInteger(voterSpentPowerKey).valueOrErrorMessage("Voter spent power value not founded")

  let upCountDapp = getInteger(voteUpCountKey).valueOrErrorMessage("Up count note found")
  let downCountDapp = getInteger(voteDownCountKey).valueOrErrorMessage("Down count note found")

  let upCount = if (voteIdType == "up") then upCountDapp - voteIdPower else upCountDapp
  let downCount = if (voteIdType == "down") then downCountDapp - voteIdPower else downCountDapp

  let isCallerVoted = getBoolean(voterVoteKey).valueOrElse(false)
  if (!isCallerVoted) then throw("You haven't voted yet")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else if(voteIdType != "up" && voteIdType != "down") then throw("Invalid type parametr")
  else {
    [
      DeleteEntry(voterVoteKey),
      DeleteEntry(voterVoteTypeKey),
      DeleteEntry(voterVoteCreatedKey),
      DeleteEntry(voterVotePowerKey),
      IntegerEntry(voterVotesCountKey, voterVotesCount - 1),
      IntegerEntry(voterSpentPowerKey, voterSpentPower - voteIdPower),

      IntegerEntry(voteUpCountKey, upCount),
      IntegerEntry(voteDownCountKey, downCount),

      IntegerEntry(voteTotalCountKey, totalCount - voteIdPower)
    ]
  }
}

@Callable(i)
func fillTreasuary() = {
  if (i.payments.size() == 0) then throw("No payment")
  else if (i.payments[0].amount == 0) then throw("Payment must be more 0")
  else if (i.payments[0].assetId != USDTAssetId) then throw("Payment must be in USDT")
  else {
    let amount = i.payments[0].amount
    let assetId = i.payments[0].assetId.value()
    let treasuaryAssetIdAvailable = "treasuary_" + assetId.toBase58String() + "_available"
    let treasuaryAssetIdTotalReceived = "treasuary_" + assetId.toBase58String() + "_totalReceived"

    let available = getInteger(treasuaryAssetIdAvailable).valueOrElse(0)
    let totalReceived = getInteger(treasuaryAssetIdTotalReceived).valueOrElse(0)
    [
      IntegerEntry(treasuaryAssetIdAvailable, available + amount),
      IntegerEntry(treasuaryAssetIdTotalReceived, totalReceived + amount)
    ] #++ addRewardsToAddresses(assetId.toBase58String(), amount)
  }
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let creationAddress = Address(base58'3PFQjjDMiZKQZdu5JqTHD7HwgSXyp9Rw9By')

let totalStakedKey = "total_staked"
let totalPowerKey = "total_power"

let POWER_LIMIT = 1000

let whitelist = [
  "3PJKmXoHJvVeQXjSJdhtkUcFDtdiQqMbUTD"
]

# Check NFT and NFT issuer
func checkNFT(asset: Asset) = {
  getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_issuer") == this.toString() &&
  asset.issuer == creationAddress &&
  asset.decimals == 0 &&
  asset.reissuable == false &&
  asset.quantity == 1
}

func getPowerNFT(asset: Asset) = {
  let params = getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_params")
  if params == "gold" then 50 else 10
}

func getCollectionIssuer(collectionId: String) = {
  let assetId = getString(creationAddress, "collection_" + collectionId + "_assetId").valueOrElse("")

  getString(creationAddress, "nft_" + assetId + "_issuer").valueOrElse("")
}

func isVotingClosed(voteId: String) = {
  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let isConfirmed = getBoolean(voteConfirmedKey).valueOrElse(false)
  let isRejected = getBoolean(voteRejectedKey).valueOrElse(false)
  isConfirmed || isRejected
}

@Callable(i)
func stake() = {
  let addressStr = i.caller.toString()
  let p = i.payments[0].valueOrErrorMessage("No payments")
  let asset = assetInfo(p.assetId.valueOrErrorMessage("Invalid payment")).valueOrErrorMessage("Invalid asset Id")
  if (p.amount > 0 && asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPower = getInteger("address_" + addressStr + "_power").valueOrElse(0)

    let nftPower = asset.getPowerNFT()

    let nftIdStr = asset.id.toBase58String()
    [
      IntegerEntry(totalStakedKey, totalStaked + 1),
      IntegerEntry(totalPowerKey, totalPower + nftPower),

      StringEntry("nft_" + nftIdStr + "_owner", addressStr),
      IntegerEntry("nft_" + nftIdStr + "_power", nftPower),

      IntegerEntry("address_" + addressStr + "_power", addressPower + nftPower)
    ]
  }
  else throw("No payments")
}

@Callable(i)
func unstake(nftIdStr: String) = {
  let addressStr = i.caller.toString()
  let asset = assetInfo(nftIdStr.fromBase58String()).valueOrErrorMessage("Invalid nft Id")
  let ownerAddress = getString("nft_" + nftIdStr + "_owner").valueOrErrorMessage("Owner data invalid")
  if (ownerAddress != addressStr) then throw("You are not the owner")
  else if (asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPower = getInteger("address_" + addressStr + "_power").valueOrElse(0)

    let nftAssetIdStr = asset.id.toBase58String()
    let nftPower = getIntegerValue("nft_" + nftAssetIdStr + "_power")
    [
      ScriptTransfer(i.caller, 1, asset.id),
      IntegerEntry(totalStakedKey, totalStaked - 1),
      IntegerEntry(totalPowerKey, totalPower - nftPower),

      DeleteEntry("nft_" + nftAssetIdStr + "_owner"),
      DeleteEntry("nft_" + nftAssetIdStr + "_power"),

      IntegerEntry("address_" + addressStr + "_power", addressPower - nftPower)
    ]
  }
  else throw("Invalid nft Id")
}

@Callable(i)
func sendToVote(collectionId: String) = {
  let issuer = collectionId.getCollectionIssuer()
  let isExist = match (getString("collection_" + collectionId + "_voteId")) {
      case t:String => true
      case _ => false
    }
  if (issuer.size() == 0) then throw("Collection issuer not found")
  else if (isExist) then throw("Collection has already been submitted for voting")
  else if (whitelist.indexOf(i.caller.toString()) == unit) then throw("Functionality temporarily unavailable")
  else if (issuer != i.caller.toString()) then throw("Only the issuer can submit to the vote")
  else {
    let voteId = sha256_16Kb(collectionId.toBytes()).toBase58String()
    let totalVotes = getInteger("total_votes").valueOrElse(0)
    [
      StringEntry("collection_" + collectionId + "_voteId", voteId),
      StringEntry("vote_" + voteId + "_collectionId", collectionId),
      StringEntry("vote_" + voteId + "_owner", i.caller.toString()),
      IntegerEntry("vote_" + voteId + "_createdAt", height),
      IntegerEntry("total_votes", totalVotes + 1)
    ]
  }
}

@Callable(i)
func removeFromVote(voteId: String) = {
  let collectionId = getString("vote_" + voteId + "_collectionId").valueOrErrorMessage("Collection Id not found")
  let owner = getString("vote_" + voteId + "_owner").valueOrErrorMessage("Owner not found")
  if (owner != i.caller.toString()) then throw("You are not the owner")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else {
    let totalVotes = getInteger("total_votes").valueOrErrorMessage("total votes value not found")
    [
      DeleteEntry("collection_" + collectionId + "_voteId"),
      DeleteEntry("vote_" + voteId + "_collectionId"),
      DeleteEntry("vote_" + voteId + "_owner"),
      DeleteEntry("vote_" + voteId + "_createdAt"),
      IntegerEntry("total_votes", totalVotes - 1)
    ]
  }
}

@Callable(i)
func vote(voteId: String, type: String) = {
  let addressStr = i.caller.toString()

  let exist = match (getString("vote_" + voteId + "_collectionId")) {
    case t:String => true
    case _ => false
  }

  let voterVoteKey = "voter_" + addressStr + "_vote_" + voteId + "_isVoted"
  let voterVoteTypeKey = "voter_" + addressStr + "_vote_" + voteId + "_type"
  let voterVotePowerKey = "voter_" + addressStr + "_vote_" + voteId + "_power"
  let voterVoteCreatedKey = "voter_" + addressStr + "_vote_" + voteId + "_created"

  let voterVotesCountKey = "voter_" + addressStr + "_votesCount"
  let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

  let voteUpCountKey = "vote_" + voteId + "_upCount"
  let voteDownCountKey = "vote_" + voteId + "_downCount"
  let voteTotalCountKey = "vote_" + voteId + "_totalCount"

  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let addressPower = getInteger("address_" + addressStr + "_power").valueOrErrorMessage("The address has no voting power")
  let totalVoteCount = getInteger(voteTotalCountKey).valueOrElse(0)

  let voterVotesCount = getInteger(voterVotesCountKey).valueOrElse(0)
  let voterSpentPower = getInteger(voterSpentPowerKey).valueOrElse(0)

  let upCountDapp = getInteger(voteUpCountKey).valueOrElse(0)
  let downCountDapp = getInteger(voteDownCountKey).valueOrElse(0)

  let upCount = if (type == "up") then upCountDapp + addressPower else upCountDapp
  let downCount = if (type == "down") then downCountDapp + addressPower else downCountDapp

  let isCallerVoted = getBoolean(voterVoteKey).valueOrElse(false)

  if (isCallerVoted) then throw("You have already voted")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else if (!exist) then throw("Collection not found")
  else if(type != "up" && type != "down") then throw("Invalid type parametr")
  else {
    let updatedVoteCount = totalVoteCount + addressPower
    let endVoteStates = if (updatedVoteCount >= POWER_LIMIT) then {
      let upPercent = fraction(upCount, 100, updatedVoteCount)
      let downPercent = fraction(downCount, 100, updatedVoteCount)
      if (upPercent >= 50) then [
        BooleanEntry(voteConfirmedKey, true)
      ]
      else [
        BooleanEntry(voteRejectedKey, true)
      ]
    } else []
    [
      BooleanEntry(voterVoteKey, true),
      StringEntry(voterVoteTypeKey, type),
      IntegerEntry(voterVoteCreatedKey, height),
      IntegerEntry(voterVotePowerKey, addressPower),
      IntegerEntry(voterVotesCountKey, voterVotesCount + 1),
      IntegerEntry(voterSpentPowerKey, voterSpentPower + addressPower),

      IntegerEntry(voteUpCountKey, upCount),
      IntegerEntry(voteDownCountKey, downCount),

      IntegerEntry(voteTotalCountKey, updatedVoteCount)
    ] ++ endVoteStates
  }
}

@Callable(i)
func unvote(voteId: String) = {
  let addressStr = i.caller.toString()

  let voterVoteKey = "voter_" + addressStr + "_vote_" + voteId + "_isVoted"
  let voterVoteTypeKey = "voter_" + addressStr + "_vote_" + voteId + "_type"
  let voterVotePowerKey = "voter_" + addressStr + "_vote_" + voteId + "_power"
  let voterVoteCreatedKey = "voter_" + addressStr + "_vote_" + voteId + "_created"

  let voterVotesCountKey = "voter_" + addressStr + "_votesCount"
  let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

  let voteUpCountKey = "vote_" + voteId + "_upCount"
  let voteDownCountKey = "vote_" + voteId + "_downCount"
  let voteTotalCountKey = "vote_" + voteId + "_totalCount"

  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let voteIdType = getString(voterVoteTypeKey).valueOrErrorMessage("Vote Id type not founded")
  let voteIdPower = getInteger(voterVotePowerKey).valueOrErrorMessage("Vote Id power not founded")
  let totalCount = getInteger(voteTotalCountKey).valueOrErrorMessage("Vote Id total count not founded")

  let voterVotesCount = getInteger(voterVotesCountKey).valueOrErrorMessage("Voter votes count value not founded")
  let voterSpentPower = getInteger(voterSpentPowerKey).valueOrErrorMessage("Voter spent power value not founded")

  let upCountDapp = getInteger(voteUpCountKey).valueOrErrorMessage("Up count note found")
  let downCountDapp = getInteger(voteDownCountKey).valueOrErrorMessage("Down count note found")

  let upCount = if (voteIdType == "up") then upCountDapp - voteIdPower else upCountDapp
  let downCount = if (voteIdType == "down") then downCountDapp - voteIdPower else downCountDapp

  let isCallerVoted = getBoolean(voterVoteKey).valueOrElse(false)
  if (!isCallerVoted) then throw("You haven't voted yet")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else if(voteIdType != "up" && voteIdType != "down") then throw("Invalid type parametr")
  else {
    [
      DeleteEntry(voterVoteKey),
      DeleteEntry(voterVoteTypeKey),
      DeleteEntry(voterVoteCreatedKey),
      DeleteEntry(voterVotePowerKey),
      IntegerEntry(voterVotesCountKey, voterVotesCount - 1),
      IntegerEntry(voterSpentPowerKey, voterSpentPower - voteIdPower),

      IntegerEntry(voteUpCountKey, upCount),
      IntegerEntry(voteDownCountKey, downCount),

      IntegerEntry(voteTotalCountKey, totalCount - voteIdPower)
    ]
  }
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let creationAddress = Address(base58'3PFQjjDMiZKQZdu5JqTHD7HwgSXyp9Rw9By')

let USDTAssetId = base58'34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ'

# global keys
let totalStakedKey = "total_staked"
let totalPowerKey = "total_power"
let totalSpentPowerKey = "total_spentPower"
let currentEpochKey = "current_epoch"
let finalVotingCandidatesKey = "final_voiting_candidates"

let allStakedAddressesKey = "all_staked_addresses"

let VOTE_POWER_LIMIT = 1000

let whitelist = [
  "3PJKmXoHJvVeQXjSJdhtkUcFDtdiQqMbUTD"
]

# Check NFT and NFT issuer
func checkNFT(asset: Asset) = {
  getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_issuer") == this.toString() &&
  asset.issuer == creationAddress &&
  asset.decimals == 0 &&
  asset.reissuable == false &&
  asset.quantity == 1
}

func getPowerNFT(asset: Asset) = {
  let params = getStringValue(creationAddress, "nft_" + asset.id.toBase58String() + "_params")
  if params == "gold" then 100 else 40
}

func getCollectionIssuer(collectionId: String) = {
  let assetId = getString(creationAddress, "collection_" + collectionId + "_assetId").valueOrElse("")

  getString(creationAddress, "nft_" + assetId + "_issuer").valueOrElse("")
}

func isVotingClosed(voteId: String) = {
  let voteConfirmedKey = "vote_" + voteId + "_confirmed"
  let voteRejectedKey = "vote_" + voteId + "_rejected"

  let isConfirmed = getBoolean(voteConfirmedKey).valueOrElse(false)
  let isRejected = getBoolean(voteRejectedKey).valueOrElse(false)
  isConfirmed || isRejected
}

# add string to state array
func addStringToStateArray(dataKey: String, item: String) = {
  let allData = getString(dataKey).valueOrElse("")
  if (!isDefined(allData.indexOf(item))) then {
    if (allData.size() == 0) then {
      [StringEntry(dataKey, item)]
    } else {
      [StringEntry(dataKey, (allData.split_51C(",") :+ item).makeString_11C(","))]
    }
  } else {
    []
  }
}

# remove string to state array
func removeItemFromStateArray(dataKey: String, item: String) = {
  let allData = getString(dataKey).valueOrErrorMessage("Data for key: '" + dataKey + "' not found")
  if (isDefined(allData.indexOf(item))) then {
    let dataList = allData.split_51C(",")
    let itemIndex = dataList.indexOf(item).value()
    [StringEntry(dataKey, dataList.removeByIndex(itemIndex).makeString_11C(","))]
  } else {
    []
  }
}

@Callable(i)
func stake() = {
  let addressStr = i.caller.toString()
  let p = i.payments[0].valueOrErrorMessage("No payments")
  let asset = assetInfo(p.assetId.valueOrErrorMessage("Invalid payment")).valueOrErrorMessage("Invalid asset Id")
  if (p.amount > 0 && asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPowerKey = "address_" + addressStr + "_power"
    let addressTotalStakedKey = "address_" + addressStr + "_totalStaked"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let addressPower = getInteger(addressPowerKey).valueOrElse(0)
    let addressTotalStaked = getInteger(addressTotalStakedKey).valueOrElse(0)
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrElse("")

    if (addressTotalStaked + 1 > 5) then throw("You can stake only 5 NFTs")
    else {
      let nftPower = asset.getPowerNFT()

      let nftIdStr = asset.id.toBase58String()

      let addressStakedNftsState = if (addressStakedNfts.size() == 0) then {
        [StringEntry(addressStakedNftsKey, nftIdStr)]
      } else {
        [StringEntry(addressStakedNftsKey, (addressStakedNfts.split(",") :+ nftIdStr).makeString(","))]
      }

      [
        IntegerEntry(totalStakedKey, totalStaked + 1),
        IntegerEntry(totalPowerKey, totalPower + nftPower),

        StringEntry("nft_" + nftIdStr + "_owner", addressStr),
        IntegerEntry("nft_" + nftIdStr + "_power", nftPower),

        IntegerEntry(addressPowerKey, addressPower + nftPower),
        IntegerEntry(addressTotalStakedKey, addressTotalStaked + 1)
      ] ++ addStringToStateArray(allStakedAddressesKey, addressStr) ++ addressStakedNftsState
    }
  }
  else throw("No payments")
}

@Callable(i)
func unstake(nftIdStr: String) = {
  let addressStr = i.caller.toString()
  let asset = assetInfo(nftIdStr.fromBase58String()).valueOrErrorMessage("Invalid nft Id")
  let ownerAddress = getString("nft_" + nftIdStr + "_owner").valueOrErrorMessage("Owner data invalid")
  if (ownerAddress != addressStr) then throw("You are not the owner")
  else if (asset.checkNFT()) then {
    # global params
    let totalStaked = getInteger(totalStakedKey).valueOrElse(0)
    let totalPower = getInteger(totalPowerKey).valueOrElse(0)

    # address params
    let addressPowerKey = "address_" + addressStr + "_power"
    let addressTotalStakedKey = "address_" + addressStr + "_totalStaked"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let addressPower = getInteger(addressPowerKey).valueOrErrorMessage("Address power value not found")
    let addressTotalStaked = getInteger(addressTotalStakedKey).valueOrErrorMessage("Address total staked value not found")
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrErrorMessage("Address staked Nfts value not found")

    let nftAssetIdStr = asset.id.toBase58String()
    let nftPower = getIntegerValue("nft_" + nftAssetIdStr + "_power")
    
    let updatedAddressPower = addressPower - nftPower
    let removeStakedAddress = if (updatedAddressPower == 0) then removeItemFromStateArray(allStakedAddressesKey, addressStr) else []

    let addressStakedNftsList = addressStakedNfts.split(",")
    let addressStakedNftIndex = addressStakedNftsList.indexOf(nftIdStr).valueOrErrorMessage("NFT not founed in address staked list")
    [
      ScriptTransfer(i.caller, 1, asset.id),
      IntegerEntry(totalStakedKey, totalStaked - 1),
      IntegerEntry(totalPowerKey, totalPower - nftPower),

      DeleteEntry("nft_" + nftAssetIdStr + "_owner"),
      DeleteEntry("nft_" + nftAssetIdStr + "_power"),

      IntegerEntry(addressPowerKey, updatedAddressPower),
      IntegerEntry(addressTotalStakedKey, addressTotalStaked - 1),

      StringEntry(addressStakedNftsKey, (addressStakedNftsList.removeByIndex(addressStakedNftIndex)).makeString(","))
    ] ++ removeStakedAddress
  }
  else throw("Invalid nft Id")
}

@Callable(i)
func sendToVote(collectionId: String) = {
  let issuer = collectionId.getCollectionIssuer()
  let isExist = match (getString("collection_" + collectionId + "_voteId")) {
      case t:String => true
      case _ => false
    }
  if (issuer.size() == 0) then throw("Collection issuer not found")
  else if (isExist) then throw("Collection has already been submitted for voting")
  else if (whitelist.indexOf(i.caller.toString()) == unit) then throw("Functionality temporarily unavailable")
  else if (issuer != i.caller.toString()) then throw("Only the issuer can submit to the vote")
  else {
    let voteId = sha256_16Kb(collectionId.toBytes()).toBase58String()
    let totalVotes = getInteger("total_votes").valueOrElse(0)
    [
      StringEntry("collection_" + collectionId + "_voteId", voteId),
      StringEntry("vote_" + voteId + "_collectionId", collectionId),
      StringEntry("vote_" + voteId + "_owner", i.caller.toString()),
      IntegerEntry("vote_" + voteId + "_createdAt", height),
      IntegerEntry("total_votes", totalVotes + 1)
    ]
  }
}

@Callable(i)
func removeFromVote(voteId: String) = {
  let collectionId = getString("vote_" + voteId + "_collectionId").valueOrErrorMessage("Collection Id not found")
  let owner = getString("vote_" + voteId + "_owner").valueOrErrorMessage("Owner not found")
  if (owner != i.caller.toString()) then throw("You are not the owner")
  else if (isVotingClosed(voteId)) then throw("Voting is closed")
  else {
    let totalVotes = getInteger("total_votes").valueOrErrorMessage("total votes value not found")
    [
      DeleteEntry("collection_" + collectionId + "_voteId"),
      DeleteEntry("vote_" + voteId + "_collectionId"),
      DeleteEntry("vote_" + voteId + "_owner"),
      DeleteEntry("vote_" + voteId + "_createdAt"),
      IntegerEntry("total_votes", totalVotes - 1)
    ]
  }
}


@Callable(i)
func voteByNFT(voteId: String, assets: String) = {
  let addressStr = i.caller.toString()
  let collectionId = getString("vote_" + voteId + "_collectionId").valueOrElse("")
  if (collectionId.size() == 0) then throw("Collection not found")
  else if (assets.size() == 0) then throw("Assets list is empty")
  else {
    let voteUpPowerKey = "vote_" + voteId + "_upPower"
    let voteDownPowerKey = "vote_" + voteId + "_downPower"
    let voteTotalPowerKey = "vote_" + voteId + "_totalPower"
    let voteUsedNftsKey = "vote_" + voteId + "_usedNfts"

    let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

    let addressPowerKey = "address_" + addressStr + "_power"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let currentEpoch = getInteger(currentEpochKey).valueOrElse(0)
    let epochSpentPowerKey = "epoch_" + currentEpoch.toString() + "_spentPower"
    let epochAddressSpentPowerKey = "epoch_" + currentEpoch.toString() + "_address_" + addressStr + "_spentPower"

    let epochSpentPower = getInteger(epochSpentPowerKey).valueOrElse(0)
    let epochAddressSpentPower = getInteger(epochAddressSpentPowerKey).valueOrElse(0)

    let upPowerDapp = getInteger(voteUpPowerKey).valueOrElse(0)
    let downPowerDapp = getInteger(voteDownPowerKey).valueOrElse(0)
    let totalVotePower = getInteger(voteTotalPowerKey).valueOrElse(0)
    let voteUsedNfts = getString(voteUsedNftsKey).valueOrElse("")

    let voterSpentPower = getInteger(voterSpentPowerKey).valueOrElse(0)
    let totalSpentPower = getInteger(totalSpentPowerKey).valueOrElse(0)

    let addressPower = getInteger(addressPowerKey).valueOrErrorMessage("You don't have power")
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrErrorMessage("You don't have staked NFTs")

    let assetsList = assets.split("|")
    func processAssets(accum: (Int, Int, List[String], List[StringEntry]), next: String) = {
      let parts = next.split("_")
      let nftId = parts[0]
      let type = parts[1]
      let power = getInteger("nft_" + nftId + "_power").valueOrErrorMessage("NFT power not found")
      let stakedOwnerIndex = addressStakedNfts.indexOf(nftId).valueOrElse(-1)

      if (power == 0) then throw("Power must be more zero")
      else if(stakedOwnerIndex == -1) then throw("Asset does not belong to you")
      else {
        let assetIndex = accum._3.indexOf(nftId).valueOrElse(-1)
        if (assetIndex == -1) then {
          if (type != "up" && type != "down") then throw("Invalid type")
          else {
            (
              accum._1 + if (type == "up") then power else 0,
              accum._2 + if (type == "down") then power else 0,
              accum._3 :+ nftId,
              accum._4 :+ StringEntry("voter_" + addressStr + "_vote_" + voteId + "_assetId_" + nftId, type + ":" + power.toString() + ":" + height.toString()) # type:power:createdAt
            )
          }
        } else accum
      }
    }
    # tuple (upCount, downCount, usedNftsList, stateEntries)
    let voteUsedNftsList = if voteUsedNfts.size() == 0 then [] else voteUsedNfts.split_51C(",")
    let processResultTuple = FOLD<5>(assetsList, (0, 0, voteUsedNftsList, []), processAssets)
    let upPower = processResultTuple._1
    let downPower = processResultTuple._2
    let powerValue = upPower + downPower

    if (powerValue > addressPower) then throw("Power exceeds power of the account")
    else if (powerValue == 0) then throw("Not enough power to vote")
    else if (processResultTuple._3.size() == 0) then throw("Used list must not be empty")
    else if (processResultTuple._4.size() == 0) then throw("State entries list must not be empty")
    else {
      
      let updateCanditatesList = if (totalVotePower + powerValue > VOTE_POWER_LIMIT)
        then addStringToStateArray(finalVotingCandidatesKey, voteId)
        else []
      [
        IntegerEntry(voterSpentPowerKey, voterSpentPower + powerValue),
        IntegerEntry(totalSpentPowerKey, totalSpentPower + powerValue),

        IntegerEntry(voteUpPowerKey, upPowerDapp + upPower),
        IntegerEntry(voteDownPowerKey, downPowerDapp + downPower),
        IntegerEntry(voteTotalPowerKey, totalVotePower + powerValue),

        StringEntry(voteUsedNftsKey, processResultTuple._3.makeString_11C(",")),

        IntegerEntry(epochSpentPowerKey, epochSpentPower + powerValue),
        IntegerEntry(epochAddressSpentPowerKey, epochAddressSpentPower + powerValue)        
      ] ++ processResultTuple._4 ++ updateCanditatesList
    }
  }
}

@Callable(i)
func unvoteByNFT(voteId: String, assets: String) = {
  let addressStr = i.caller.toString()
  let collectionId = getString("vote_" + voteId + "_collectionId").valueOrElse("")
  if (collectionId.size() == 0) then throw("Collection not found")
  else if (assets.size() == 0) then throw("Assets list is empty")
  else {
    let voteUpPowerKey = "vote_" + voteId + "_upPower"
    let voteDownPowerKey = "vote_" + voteId + "_downPower"
    let voteTotalPowerKey = "vote_" + voteId + "_totalPower"
    let voteUsedNftsKey = "vote_" + voteId + "_usedNfts"

    let voterSpentPowerKey = "voter_" + addressStr + "_spentPower"

    let addressPowerKey = "address_" + addressStr + "_power"
    let addressStakedNftsKey = "address_" + addressStr + "_stakedNfts"

    let currentEpoch = getInteger(currentEpochKey).valueOrElse(0)
    let epochSpentPowerKey = "epoch_" + currentEpoch.toString() + "_spentPower"
    let epochAddressSpentPowerKey = "epoch_" + currentEpoch.toString() + "_address_" + addressStr + "_spentPower"

    let epochSpentPower = getInteger(epochSpentPowerKey).valueOrErrorMessage("Epoch spent power not found")
    let epochAddressSpentPower = getInteger(epochAddressSpentPowerKey).valueOrErrorMessage("Epoch address spent power not found")

    let upPowerDapp = getInteger(voteUpPowerKey).valueOrErrorMessage("Up vote power not found")
    let downPowerDapp = getInteger(voteDownPowerKey).valueOrErrorMessage("Down vote power not found")
    let totalVotePower = getInteger(voteTotalPowerKey).valueOrErrorMessage("Total vote power not found")
    let voteUsedNfts = getString(voteUsedNftsKey).valueOrErrorMessage("Vote used power not found")

    let voterSpentPower = getInteger(voterSpentPowerKey).valueOrErrorMessage("Voter spent power not found")
    let totalSpentPower = getInteger(totalSpentPowerKey).valueOrErrorMessage("Total spent power not found")

    let addressPower = getInteger(addressPowerKey).valueOrErrorMessage("You don't have power")
    let addressStakedNfts = getString(addressStakedNftsKey).valueOrErrorMessage("You don't have staked NFTs")

    let assetsList = assets.split("|")
    func processAssets(accum: (Int, Int, List[String], List[DeleteEntry]), next: String) = {
      let assetVote = getString("voter_" + addressStr + "_vote_" + voteId + "_assetId_" + next).valueOrErrorMessage("Vote asset data not found")
      let parts = assetVote.split(":")
      let type = parts[0]
      let power = parseInt(parts[1]).valueOrElse(0)
      let stakedOwnerIndex = addressStakedNfts.indexOf(next).valueOrElse(-1)

      if (power == 0) then throw("Power must be more zero")
      else if(stakedOwnerIndex == -1) then throw("Asset does not belong to you")
      else {
        let assetUsedIndex = accum._3.indexOf(next).valueOrElse(-1)
        if (assetUsedIndex >= 0) then {
          if (type != "up" && type != "down") then throw("Invalid type")
          else {
            (
              accum._1 + if (type == "up") then power else 0,
              accum._2 + if (type == "down") then power else 0,
              accum._3.removeByIndex(assetUsedIndex),
              accum._4 :+ DeleteEntry("voter_" + addressStr + "_vote_" + voteId + "_assetId_" + next)
            )
          }
        } else accum
      }
    }
    # tuple (upCount, downCount, usedNftsList, stateEntries)
    let processResultTuple = FOLD<5>(assetsList, (0, 0, voteUsedNfts.split_51C(","), []), processAssets)
    let upPower = processResultTuple._1
    let downPower = processResultTuple._2
    let powerValue = upPower + downPower

    if (powerValue > addressPower) then throw("Power exceeds power of the account")
    else if (powerValue == 0) then throw("Not enough power to unvote")
    else if (processResultTuple._4.size() == 0) then throw("State entries list must not be empty")
    else {
      let updateCanditatesList = if (totalVotePower - powerValue < VOTE_POWER_LIMIT) then removeItemFromStateArray(finalVotingCandidatesKey, voteId) else []
      [
        IntegerEntry(voterSpentPowerKey, voterSpentPower - powerValue),
        IntegerEntry(totalSpentPowerKey, totalSpentPower - powerValue),

        IntegerEntry(voteUpPowerKey, upPowerDapp - upPower),
        IntegerEntry(voteDownPowerKey, downPowerDapp - downPower),
        StringEntry(voteUsedNftsKey, processResultTuple._3.makeString_11C(",")),

        IntegerEntry(epochSpentPowerKey, epochSpentPower - powerValue),
        IntegerEntry(epochAddressSpentPowerKey, epochAddressSpentPower - powerValue),

        IntegerEntry(voteTotalPowerKey, totalVotePower - powerValue)
      ] ++ processResultTuple._4
    }
  }
}

@Callable(i)
func fillTreasuary() = {
  if (i.payments.size() == 0) then throw("No payment")
  else if (i.payments[0].amount == 0) then throw("Payment must be more 0")
  else if (i.payments[0].assetId != USDTAssetId) then throw("Payment must be in USDT")
  else {
    let amount = i.payments[0].amount
    let assetId = i.payments[0].assetId.value()

    let finalVotingCandidates = getString(finalVotingCandidatesKey).valueOrElse("")
    if (finalVotingCandidates.size() == 0) then throw("Canditates list is empty")
    else {
      let currentEpoch = getInteger(currentEpochKey).valueOrElse(0)
      let finalVotingCandidatesList = finalVotingCandidates.split(",")
      func processVote(accum: (Int, List[BooleanEntry]), next: String) = {
        let voteUpPowerKey = "vote_" + next + "_upPower"
        let voteDownPowerKey = "vote_" + next + "_downPower"
        let voteTotalPowerKey = "vote_" + next + "_totalPower"

        let voteUpPower = getInteger(voteUpPowerKey).valueOrElse(0)
        let voteDownPower = getInteger(voteDownPowerKey).valueOrElse(0)
        let voteTotalPower = getInteger(voteTotalPowerKey).valueOrElse(0)

        if (voteTotalPower == 0) then throw("Invalid total power")
        else if (voteTotalPower < VOTE_POWER_LIMIT) then throw("Power less than limit")
        else if (voteUpPower + voteDownPower == 0) then throw("Invalid up, down power")
        else {
          let upPercent = fraction(voteUpPower, 100, voteTotalPower)
          let finalVoteState =
            if (upPercent > 50)
              then [BooleanEntry("vote_" + next + "_confirmed", true)]
              else [BooleanEntry("vote_" + next + "_rejected", true)]
          (
            accum._1 + voteTotalPower,
            accum._2 :+ finalVoteState
          )
        }
      }
      let resultTuple = FOLD<10>(finalVotingCandidatesList, (0, []), processVote)
      if (resultTuple._1 == 0) then throw("No power after process canditates")
      else {
        [
          IntegerEntry(currentEpochKey, currentEpoch + 1)
        ] ++ resultTuple._2
      }
    }
    # let treasuaryAssetIdAvailable = "treasuary_" + assetId.toBase58String() + "_available"
    # let treasuaryAssetIdTotalReceived = "treasuary_" + assetId.toBase58String() + "_totalReceived"

    # let available = getInteger(treasuaryAssetIdAvailable).valueOrElse(0)
    # let totalReceived = getInteger(treasuaryAssetIdTotalReceived).valueOrElse(0)
    # [
    #   IntegerEntry(treasuaryAssetIdAvailable, available + amount),
    #   IntegerEntry(treasuaryAssetIdTotalReceived, totalReceived + amount)
    # ] #++ addRewardsToAddresses(assetId.toBase58String(), amount)
  }
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)